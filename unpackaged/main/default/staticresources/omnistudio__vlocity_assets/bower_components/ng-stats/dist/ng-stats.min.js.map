{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///dist/ng-stats.min.js","webpack:///webpack/bootstrap 17fe47d2f2434b59ad2e","webpack:///./index.js","webpack:///external \"angular\""],"names":["root","factory","exports","module","require","define","amd","this","__WEBPACK_EXTERNAL_MODULE_1__","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","hijackDigest","digestIsHijacked","scopePrototype","Object","getPrototypeOf","getRootScope","oldDigest","$digest","start","timerNow","apply","arguments","diff","updateData","getWatcherCount","isChromeApp","chrome","storage","local","autoload","options","window","self","angular","showAngularStats","setTimeout","initOptions","opts","sessionStorage","removeItem","autoloadKey","localStorage","position","extend","htmlId","rootScope","undefined","digestTimeThreshold","watchCountThreshold","trackDigest","trackWatches","logDigest","logWatches","styles","background","borderBottom","borderRight","color","fontFamily","width","zIndex","textAlign","top","indexOf","bottom","right","left","$rootScope","track","thingToTrack","listenerCollection","diffOnly","capThingToTrack","charAt","toUpperCase","slice","returnData","tracked","length","push","log","thingToLog","capThingToLog","last","colorLog","console","getColor","metric","threshold","addDataToCanvas","watchCount","digestLength","averageDigest","lastDigestLength","digestColor","lastWatchCount","nullOrUndef","watchColor","$watchCount","text","css","$digestTime","toFixed","ctx","cvs","getContext","noDigestSteps","fillStyle","fillRect","graphSz","height","Math","max","shiftLeft","state","active","imageData","getImageData","putImageData","listeners","current","$el","remove","setItem","JSON","stringify","Error","bodyEl","element","document","body","append","find","next","attr","ngStatsAddToCanvas","$$phase","scopeEl","querySelector","scopeSelectors","scope","$root","clearTimeout","watchCountTimeout","now","lastWatchCountRun","getWatcherCountForScope","getWatcherCountForElement","startingScope","getClosestChildScope","getWatchersFromScope","$$watchers","forEach","listener","item","count","iterateScopes","childScope","currentScope","fn","_makeScopeReference","ret","iterateChildren","iterateSiblings","$$nextSibling","$$childHead","getScopeById","myScope","$id","_isScopeId","defineProperty","value","_angular","_angular2","version","performance","Date","autoloadOptions","parse","directive","findRootOfElement","el","parent","parentElement","index","watchCountRoot","onDigestLengthUpdate","onWatchCountUpdate","link","attrs","setupDigestLengthElement","hasOwnProperty","digestEl","directiveIndex","dirDigestNode","setupWatchCountElement","watchCountEl","rootParent","addWatchCountListener","addDigestLengthListener","destroyListeners","$on"],"mappings":"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","file":"dist/ng-stats.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"showAngularStats\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"showAngularStats\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","//! ng-stats version 2.5.4 built with ♥ by Kent C. Dodds <kent@doddsfamily.us> (http://kent.doddsfamily.us), Viper Bailey <jinxidoru@gmail.com> (http://jinxidoru.blogspot.com), Daniel Lamb <dlamb.open.source@gmail.com> (http://daniellmb.com) (ó ì_í)=óò=(ì_í ò)\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"angular\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([\"angular\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"showAngularStats\"] = factory(require(\"angular\"));\n\telse\n\t\troot[\"showAngularStats\"] = factory(root[\"angular\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t/* eslint no-console:0 */\n\t'use strict';\n\t\n\tObject.defineProperty(exports, '__esModule', {\n\t  value: true\n\t});\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\t\n\tvar _angular = __webpack_require__(1);\n\t\n\tvar _angular2 = _interopRequireDefault(_angular);\n\t\n\tvar angular = _angular2['default'];\n\t\n\t/* istanbul ignore next */\n\tif (!angular.version) {\n\t  // we're doing this because some versions\n\t  // of angular don't expose itself correctly\n\t  angular = window.angular;\n\t}\n\t\n\texports['default'] = showAngularStats;\n\t\n\tvar autoloadKey = 'showAngularStats_autoload';\n\tvar current = null;\n\t// define the timer function to use based upon whether or not 'performance is available'\n\tvar timerNow = window.self.performance && window.self.performance.now ? function () {\n\t  return window.self.performance.now();\n\t} : function () {\n\t  return Date.now();\n\t};\n\t\n\tvar lastWatchCountRun = timerNow();\n\tvar watchCountTimeout = null;\n\tvar lastWatchCount = getWatcherCount() || 0;\n\tvar lastDigestLength = 0;\n\tvar scopeSelectors = '.ng-scope, .ng-isolate-scope';\n\tvar $rootScope;\n\t\n\tvar digestIsHijacked = false;\n\t\n\tvar listeners = {\n\t  watchCount: {},\n\t  digestLength: {}\n\t};\n\t\n\t// Hijack $digest to time it and update data on every digest.\n\tfunction hijackDigest() {\n\t  if (digestIsHijacked) {\n\t    return;\n\t  }\n\t  digestIsHijacked = true;\n\t  var scopePrototype = Object.getPrototypeOf(getRootScope());\n\t  var oldDigest = scopePrototype.$digest;\n\t  scopePrototype.$digest = function $digest() {\n\t    var start = timerNow();\n\t    oldDigest.apply(this, arguments);\n\t    var diff = timerNow() - start;\n\t    updateData(getWatcherCount(), diff);\n\t  };\n\t}\n\t\n\t// used to prevent localstorage error in chrome packaged apps\n\tfunction isChromeApp() {\n\t  return typeof chrome !== 'undefined' && typeof chrome.storage !== 'undefined' && typeof chrome.storage.local !== 'undefined';\n\t}\n\t\n\t// check for autoload\n\tvar autoloadOptions = sessionStorage[autoloadKey] || !isChromeApp() && localStorage[autoloadKey];\n\tif (autoloadOptions) {\n\t  autoload(JSON.parse(autoloadOptions));\n\t}\n\t\n\tfunction autoload(options) {\n\t  if (window.self.angular && getRootScope()) {\n\t    showAngularStats(options);\n\t  } else {\n\t    // wait for angular to load...\n\t    setTimeout(function () {\n\t      autoload(options);\n\t    }, 200);\n\t  }\n\t}\n\t\n\tfunction initOptions(opts) {\n\t\n\t  // Remove autoload if they did not specifically request it\n\t  if (opts === false || !opts.autoload) {\n\t    sessionStorage.removeItem(autoloadKey);\n\t    localStorage.removeItem(autoloadKey);\n\t    // do nothing if the argument is false\n\t    if (opts === false) {\n\t      return;\n\t    }\n\t  }\n\t\n\t  opts.position = opts.position || 'top-left';\n\t  opts = angular.extend({\n\t    htmlId: null,\n\t    rootScope: undefined,\n\t    digestTimeThreshold: 16,\n\t    watchCountThreshold: 2000,\n\t    autoload: false,\n\t    trackDigest: false,\n\t    trackWatches: false,\n\t    logDigest: false,\n\t    logWatches: false,\n\t    styles: {\n\t      position: 'fixed',\n\t      background: 'black',\n\t      borderBottom: '1px solid #666',\n\t      borderRight: '1px solid #666',\n\t      color: '#666',\n\t      fontFamily: 'Courier',\n\t      width: 130,\n\t      zIndex: 9999,\n\t      textAlign: 'right',\n\t      top: opts.position.indexOf('top') === -1 ? null : 0,\n\t      bottom: opts.position.indexOf('bottom') === -1 ? null : 0,\n\t      right: opts.position.indexOf('right') === -1 ? null : 0,\n\t      left: opts.position.indexOf('left') === -1 ? null : 0\n\t    }\n\t  }, opts || {});\n\t\n\t  // for ionic support\n\t  if (opts.rootScope) {\n\t    $rootScope = opts.rootScope;\n\t  }\n\t\n\t  return opts;\n\t}\n\t\n\tfunction showAngularStats(opts) {\n\t  /* eslint max-statements:[2, 45] */\n\t  /* eslint complexity:[2, 18] */\n\t  /* eslint consistent-return:0 */\n\t  // TODO ^^ fix these things...\n\t  opts = opts !== undefined ? opts : {};\n\t  var returnData = {\n\t    listeners: listeners\n\t  };\n\t  // delete the previous one\n\t  if (current) {\n\t    current.$el && current.$el.remove();\n\t    current.active = false;\n\t    current = null;\n\t  }\n\t\n\t  // Implemented in separate function due to webpack's statement count limit\n\t  opts = initOptions(opts);\n\t\n\t  if (!opts) {\n\t    return;\n\t  }\n\t\n\t  hijackDigest();\n\t\n\t  // setup the state\n\t  var state = current = { active: true };\n\t\n\t  // auto-load on startup\n\t  if (opts.autoload) {\n\t    if (opts.autoload === 'localStorage') {\n\t      localStorage.setItem(autoloadKey, JSON.stringify(opts));\n\t    } else if (opts.autoload === 'sessionStorage' || typeof opts.autoload === 'boolean') {\n\t      sessionStorage.setItem(autoloadKey, JSON.stringify(opts));\n\t    } else {\n\t      throw new Error('Invalid value for autoload: ' + opts.autoload + ' can only be \"localStorage\" \"sessionStorage\" or boolean.');\n\t    }\n\t  }\n\t\n\t  // general variables\n\t  var bodyEl = angular.element(document.body);\n\t  var noDigestSteps = 0;\n\t\n\t  // add the DOM element\n\t  var htmlId = opts.htmlId ? ' id=\"' + opts.htmlId + '\"' : '';\n\t  state.$el = angular.element('<div' + htmlId + '><canvas></canvas><div><span></span> | <span></span></div></div>').css(opts.styles);\n\t  bodyEl.append(state.$el);\n\t  var $watchCount = state.$el.find('span');\n\t  var $digestTime = $watchCount.next();\n\t\n\t  // initialize the canvas\n\t  var graphSz = { width: 130, height: 40 };\n\t  var cvs = state.$el.find('canvas').attr(graphSz)[0];\n\t\n\t  // add listeners\n\t  listeners.digestLength.ngStatsAddToCanvas = function (digestLength) {\n\t    addDataToCanvas(null, digestLength);\n\t  };\n\t\n\t  listeners.watchCount.ngStatsAddToCanvas = function (watchCount) {\n\t    addDataToCanvas(watchCount);\n\t  };\n\t\n\t  track('digest', listeners.digestLength);\n\t  track('watches', listeners.watchCount, true);\n\t\n\t  log('digest', listeners.digestLength);\n\t  log('watches', listeners.watchCount, true);\n\t\n\t  function track(thingToTrack, listenerCollection, diffOnly) {\n\t    var capThingToTrack = thingToTrack.charAt(0).toUpperCase() + thingToTrack.slice(1);\n\t    if (opts['track' + capThingToTrack]) {\n\t      returnData[thingToTrack] = [];\n\t      listenerCollection['track + capThingToTrack'] = function (tracked) {\n\t        if (!diffOnly || returnData[thingToTrack][returnData.length - 1] !== tracked) {\n\t          returnData[thingToTrack][returnData.length - 1] = tracked;\n\t          returnData[thingToTrack].push(tracked);\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  function log(thingToLog, listenerCollection, diffOnly) {\n\t    var capThingToLog = thingToLog.charAt(0).toUpperCase() + thingToLog.slice(1);\n\t    if (opts['log' + capThingToLog]) {\n\t      var last;\n\t      listenerCollection['log' + capThingToLog] = function (tracked) {\n\t        if (!diffOnly || last !== tracked) {\n\t          last = tracked;\n\t          var color = colorLog(thingToLog, tracked);\n\t          if (color) {\n\t            console.log('%c' + thingToLog + ':', color, tracked);\n\t          } else {\n\t            console.log(thingToLog + ':', tracked);\n\t          }\n\t        }\n\t      };\n\t    }\n\t  }\n\t\n\t  function getColor(metric, threshold) {\n\t    if (metric > threshold) {\n\t      return 'red';\n\t    } else if (metric > 0.7 * threshold) {\n\t      return 'orange';\n\t    }\n\t    return 'green';\n\t  }\n\t\n\t  function colorLog(thingToLog, tracked) {\n\t    var color;\n\t    if (thingToLog === 'digest') {\n\t      color = 'color:' + getColor(tracked, opts.digestTimeThreshold);\n\t    } else if (thingToLog === 'watches') {\n\t      color = 'color:' + getColor(tracked, opts.watchCountThreshold);\n\t    }\n\t    return color;\n\t  }\n\t\n\t  function addDataToCanvas(watchCount, digestLength) {\n\t    var averageDigest = digestLength || lastDigestLength;\n\t    var digestColor = getColor(averageDigest, opts.digestTimeThreshold);\n\t    lastWatchCount = nullOrUndef(watchCount) ? lastWatchCount : watchCount;\n\t    var watchColor = getColor(lastWatchCount, opts.watchCountThreshold);\n\t    lastDigestLength = nullOrUndef(digestLength) ? lastDigestLength : digestLength;\n\t    $watchCount.text(lastWatchCount).css({ color: watchColor });\n\t    $digestTime.text(lastDigestLength.toFixed(2)).css({ color: digestColor });\n\t\n\t    if (!digestLength) {\n\t      return;\n\t    }\n\t\n\t    // color the sliver if this is the first step\n\t    var ctx = cvs.getContext('2d');\n\t    if (noDigestSteps > 0) {\n\t      noDigestSteps = 0;\n\t      ctx.fillStyle = '#333';\n\t      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n\t    }\n\t\n\t    // mark the point on the graph\n\t    ctx.fillStyle = digestColor;\n\t    ctx.fillRect(graphSz.width - 1, Math.max(0, graphSz.height - averageDigest), 2, 2);\n\t  }\n\t\n\t  // Shift the canvas to the left.\n\t  function shiftLeft() {\n\t    if (state.active) {\n\t      setTimeout(shiftLeft, 250);\n\t      var ctx = cvs.getContext('2d');\n\t      var imageData = ctx.getImageData(1, 0, graphSz.width - 1, graphSz.height);\n\t      ctx.putImageData(imageData, 0, 0);\n\t      ctx.fillStyle = noDigestSteps++ > 2 ? 'black' : '#333';\n\t      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n\t    }\n\t  }\n\t\n\t  // start everything\n\t  shiftLeft();\n\t  if (!$rootScope.$$phase) {\n\t    $rootScope.$digest();\n\t  }\n\t\n\t  return returnData;\n\t}\n\t\n\tangular.module('angularStats', []).directive('angularStats', function () {\n\t  var index = 1;\n\t  return {\n\t    scope: {\n\t      digestLength: '@',\n\t      watchCount: '@',\n\t      watchCountRoot: '@',\n\t      onDigestLengthUpdate: '&?',\n\t      onWatchCountUpdate: '&?'\n\t    },\n\t    link: function link(scope, el, attrs) {\n\t      hijackDigest();\n\t      var directiveIndex = index++;\n\t\n\t      setupDigestLengthElement();\n\t      setupWatchCountElement();\n\t      addWatchCountListener();\n\t      addDigestLengthListener();\n\t      scope.$on('$destroy', destroyListeners);\n\t\n\t      function setupDigestLengthElement() {\n\t        if (attrs.hasOwnProperty('digestLength')) {\n\t          var digestEl = el;\n\t          if (attrs.digestLength) {\n\t            digestEl = angular.element(el[0].querySelector(attrs.digestLength));\n\t          }\n\t          listeners.digestLength['ngStatsDirective' + directiveIndex] = function (length) {\n\t            window.dirDigestNode = digestEl[0];\n\t            digestEl.text((length || 0).toFixed(2));\n\t          };\n\t        }\n\t      }\n\t\n\t      function setupWatchCountElement() {\n\t        if (attrs.hasOwnProperty('watchCount')) {\n\t          var watchCountRoot;\n\t          var watchCountEl = el;\n\t          if (scope.watchCount) {\n\t            watchCountEl = angular.element(el[0].querySelector(attrs.watchCount));\n\t          }\n\t\n\t          if (scope.watchCountRoot) {\n\t            if (scope.watchCountRoot === 'this') {\n\t              watchCountRoot = el;\n\t            } else {\n\t              // In the case this directive is being compiled and it's not in the dom,\n\t              // we're going to do the find from the root of what we have...\n\t              var rootParent;\n\t              if (attrs.hasOwnProperty('watchCountOfChild')) {\n\t                rootParent = el[0];\n\t              } else {\n\t                rootParent = findRootOfElement(el);\n\t              }\n\t              watchCountRoot = angular.element(rootParent.querySelector(scope.watchCountRoot));\n\t              if (!watchCountRoot.length) {\n\t                throw new Error('no element at selector: ' + scope.watchCountRoot);\n\t              }\n\t            }\n\t          }\n\t\n\t          listeners.watchCount['ngStatsDirective' + directiveIndex] = function (count) {\n\t            var watchCount = count;\n\t            if (watchCountRoot) {\n\t              watchCount = getWatcherCountForElement(watchCountRoot);\n\t            }\n\t            watchCountEl.text(watchCount);\n\t          };\n\t        }\n\t      }\n\t\n\t      function addWatchCountListener() {\n\t        if (attrs.hasOwnProperty('onWatchCountUpdate')) {\n\t          listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex] = function (count) {\n\t            scope.onWatchCountUpdate({ watchCount: count });\n\t          };\n\t        }\n\t      }\n\t\n\t      function addDigestLengthListener() {\n\t        if (attrs.hasOwnProperty('onDigestLengthUpdate')) {\n\t          listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex] = function (length) {\n\t            scope.onDigestLengthUpdate({ digestLength: length });\n\t          };\n\t        }\n\t      }\n\t\n\t      function destroyListeners() {\n\t        delete listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex];\n\t        delete listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex];\n\t        delete listeners.digestLength['ngStatsDirective' + directiveIndex];\n\t        delete listeners.watchCount['ngStatsDirective' + directiveIndex];\n\t      }\n\t    }\n\t  };\n\t\n\t  function findRootOfElement(el) {\n\t    var parent = el[0];\n\t    while (parent.parentElement) {\n\t      parent = parent.parentElement;\n\t    }\n\t    return parent;\n\t  }\n\t});\n\t\n\t// UTILITY FUNCTIONS\n\t\n\tfunction getRootScope() {\n\t  if ($rootScope) {\n\t    return $rootScope;\n\t  }\n\t  var scopeEl = document.querySelector(scopeSelectors);\n\t  if (!scopeEl) {\n\t    return null;\n\t  }\n\t  $rootScope = angular.element(scopeEl).scope().$root;\n\t  return $rootScope;\n\t}\n\t\n\t// Uses timeouts to ensure that this is only run every 300ms (it's a perf bottleneck)\n\tfunction getWatcherCount() {\n\t  clearTimeout(watchCountTimeout);\n\t  var now = timerNow();\n\t  if (now - lastWatchCountRun > 300) {\n\t    lastWatchCountRun = now;\n\t    lastWatchCount = getWatcherCountForScope();\n\t  } else {\n\t    watchCountTimeout = setTimeout(function () {\n\t      updateData(getWatcherCount());\n\t    }, 350);\n\t  }\n\t  return lastWatchCount;\n\t}\n\t\n\tfunction getWatcherCountForElement(element) {\n\t  var startingScope = getClosestChildScope(element);\n\t  return getWatcherCountForScope(startingScope);\n\t}\n\t\n\tfunction getClosestChildScope(element) {\n\t  element = angular.element(element);\n\t  var scope = element.scope();\n\t  if (!scope) {\n\t    element = angular.element(element.querySelector(scopeSelectors));\n\t    scope = element.scope();\n\t  }\n\t  return scope;\n\t}\n\t\n\tfunction getWatchersFromScope(scope) {\n\t  return scope && scope.$$watchers ? scope.$$watchers : [];\n\t}\n\t\n\t// iterate through listeners to call them with the watchCount and digestLength\n\tfunction updateData(watchCount, digestLength) {\n\t  // update the listeners\n\t  if (!nullOrUndef(watchCount)) {\n\t    angular.forEach(listeners.watchCount, function (listener) {\n\t      listener(watchCount);\n\t    });\n\t  }\n\t  if (!nullOrUndef(digestLength)) {\n\t    angular.forEach(listeners.digestLength, function (listener) {\n\t      listener(digestLength);\n\t    });\n\t  }\n\t}\n\t\n\tfunction nullOrUndef(item) {\n\t  return item === null || item === undefined;\n\t}\n\t\n\tfunction getWatcherCountForScope(scope) {\n\t  var count = 0;\n\t  iterateScopes(scope, function (childScope) {\n\t    count += getWatchersFromScope(childScope).length;\n\t  });\n\t  return count;\n\t}\n\t\n\tfunction iterateScopes(currentScope, fn) {\n\t  if (typeof currentScope === 'function') {\n\t    fn = currentScope;\n\t    currentScope = null;\n\t  }\n\t  currentScope = currentScope || getRootScope();\n\t  currentScope = _makeScopeReference(currentScope);\n\t  if (!currentScope) {\n\t    return;\n\t  }\n\t  var ret = fn(currentScope);\n\t  if (ret === false) {\n\t    return ret;\n\t  }\n\t  return iterateChildren(currentScope, fn);\n\t}\n\t\n\tfunction iterateSiblings(start, fn) {\n\t  var ret;\n\t  /* eslint no-extra-boolean-cast:0 */\n\t  while (!!(start = start.$$nextSibling)) {\n\t    ret = fn(start);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t\n\t    ret = iterateChildren(start, fn);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction iterateChildren(start, fn) {\n\t  var ret;\n\t  while (!!(start = start.$$childHead)) {\n\t    ret = fn(start);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t\n\t    ret = iterateSiblings(start, fn);\n\t    if (ret === false) {\n\t      break;\n\t    }\n\t  }\n\t  return ret;\n\t}\n\t\n\tfunction getScopeById(id) {\n\t  var myScope = null;\n\t  iterateScopes(function (scope) {\n\t    if (scope.$id === id) {\n\t      myScope = scope;\n\t      return false;\n\t    }\n\t  });\n\t  return myScope;\n\t}\n\t\n\tfunction _makeScopeReference(scope) {\n\t  if (_isScopeId(scope)) {\n\t    scope = getScopeById(scope);\n\t  }\n\t  return scope;\n\t}\n\t\n\tfunction _isScopeId(scope) {\n\t  return typeof scope === 'string' || typeof scope === 'number';\n\t}\n\tmodule.exports = exports['default'];\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\tmodule.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** dist/ng-stats.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 17fe47d2f2434b59ad2e\n **/","/* eslint no-console:0 */\nimport ng from 'angular';\n\nlet angular = ng;\n\n/* istanbul ignore next */\nif (!angular.version) {\n  // we're doing this because some versions\n  // of angular don't expose itself correctly\n  angular = window.angular;\n}\n\nexport default showAngularStats;\n\nvar autoloadKey = 'showAngularStats_autoload';\nvar current = null;\n// define the timer function to use based upon whether or not 'performance is available'\nvar timerNow = window.self.performance && window.self.performance.now\n  ? () => window.self.performance.now()\n  : () => Date.now();\n\nvar lastWatchCountRun = timerNow();\nvar watchCountTimeout = null;\nvar lastWatchCount = getWatcherCount() || 0;\nvar lastDigestLength = 0;\nvar scopeSelectors = '.ng-scope, .ng-isolate-scope';\nvar $rootScope;\n\nvar digestIsHijacked = false;\n\nvar listeners = {\n  watchCount: {},\n  digestLength: {}\n};\n\n// Hijack $digest to time it and update data on every digest.\nfunction hijackDigest() {\n  if (digestIsHijacked) {\n    return;\n  }\n  digestIsHijacked = true;\n  var scopePrototype = Object.getPrototypeOf(getRootScope());\n  var oldDigest = scopePrototype.$digest;\n  scopePrototype.$digest = function $digest() {\n    var start = timerNow();\n    oldDigest.apply(this, arguments);\n    var diff = (timerNow() - start);\n    updateData(getWatcherCount(), diff);\n  };\n}\n\n// used to prevent localstorage error in chrome packaged apps\nfunction isChromeApp() {\n  return (typeof chrome !== 'undefined' &&\n  typeof chrome.storage !== 'undefined' &&\n  typeof chrome.storage.local !== 'undefined');\n}\n\n// check for autoload\nvar autoloadOptions = sessionStorage[autoloadKey] || (!isChromeApp() && localStorage[autoloadKey]);\nif (autoloadOptions) {\n  autoload(JSON.parse(autoloadOptions));\n}\n\nfunction autoload(options) {\n  if (window.self.angular && getRootScope()) {\n    showAngularStats(options);\n  } else {\n    // wait for angular to load...\n    setTimeout(function() {\n      autoload(options);\n    }, 200);\n  }\n}\n\nfunction initOptions(opts) {\n\n  // Remove autoload if they did not specifically request it\n  if (opts === false || !opts.autoload) {\n    sessionStorage.removeItem(autoloadKey);\n    localStorage.removeItem(autoloadKey);\n    // do nothing if the argument is false\n    if (opts === false) {\n      return;\n    }\n  }\n\n  opts.position = opts.position || 'top-left';\n  opts = angular.extend({\n    htmlId: null,\n    rootScope: undefined,\n    digestTimeThreshold: 16,\n    watchCountThreshold: 2000,\n    autoload: false,\n    trackDigest: false,\n    trackWatches: false,\n    logDigest: false,\n    logWatches: false,\n    styles: {\n      position: 'fixed',\n      background: 'black',\n      borderBottom: '1px solid #666',\n      borderRight: '1px solid #666',\n      color: '#666',\n      fontFamily: 'Courier',\n      width: 130,\n      zIndex: 9999,\n      textAlign: 'right',\n      top: opts.position.indexOf('top') === -1 ? null : 0,\n      bottom: opts.position.indexOf('bottom') === -1 ? null : 0,\n      right: opts.position.indexOf('right') === -1 ? null : 0,\n      left: opts.position.indexOf('left') === -1 ? null : 0\n    }\n  }, opts || {});\n\n  // for ionic support\n  if (opts.rootScope) {\n    $rootScope = opts.rootScope;\n  }\n\n  return opts;\n}\n\nfunction showAngularStats(opts) {\n  /* eslint max-statements:[2, 45] */\n  /* eslint complexity:[2, 18] */\n  /* eslint consistent-return:0 */\n  // TODO ^^ fix these things...\n  opts = opts !== undefined ? opts : {};\n  var returnData = {\n    listeners: listeners\n  };\n  // delete the previous one\n  if (current) {\n    current.$el && current.$el.remove();\n    current.active = false;\n    current = null;\n  }\n\n  // Implemented in separate function due to webpack's statement count limit\n  opts = initOptions(opts);\n\n  if(!opts) {\n    return;\n  }\n\n  hijackDigest();\n\n  // setup the state\n  var state = current = {active: true};\n\n  // auto-load on startup\n  if (opts.autoload) {\n    if (opts.autoload === 'localStorage') {\n      localStorage.setItem(autoloadKey, JSON.stringify(opts));\n    } else if (opts.autoload === 'sessionStorage' || typeof opts.autoload === 'boolean') {\n      sessionStorage.setItem(autoloadKey, JSON.stringify(opts));\n    } else {\n      throw new Error(\n        'Invalid value for autoload: ' + opts.autoload + ' can only be \"localStorage\" \"sessionStorage\" or boolean.'\n      );\n    }\n  }\n\n  // general variables\n  var bodyEl = angular.element(document.body);\n  var noDigestSteps = 0;\n\n  // add the DOM element\n  var htmlId = opts.htmlId ? (' id=\"' + opts.htmlId + '\"') : '';\n  state.$el = angular.element('<div' + htmlId +\n      '><canvas></canvas><div><span></span> | <span></span></div></div>').css(opts.styles);\n  bodyEl.append(state.$el);\n  var $watchCount = state.$el.find('span');\n  var $digestTime = $watchCount.next();\n\n  // initialize the canvas\n  var graphSz = {width: 130, height: 40};\n  var cvs = state.$el.find('canvas').attr(graphSz)[0];\n\n\n  // add listeners\n  listeners.digestLength.ngStatsAddToCanvas = function(digestLength) {\n    addDataToCanvas(null, digestLength);\n  };\n\n  listeners.watchCount.ngStatsAddToCanvas = function(watchCount) {\n    addDataToCanvas(watchCount);\n  };\n\n  track('digest', listeners.digestLength);\n  track('watches', listeners.watchCount, true);\n\n  log('digest', listeners.digestLength);\n  log('watches', listeners.watchCount, true);\n\n  function track(thingToTrack, listenerCollection, diffOnly) {\n    var capThingToTrack = thingToTrack.charAt(0).toUpperCase() + thingToTrack.slice(1);\n    if (opts['track' + capThingToTrack]) {\n      returnData[thingToTrack] = [];\n      listenerCollection['track + capThingToTrack'] = function(tracked) {\n        if (!diffOnly || returnData[thingToTrack][returnData.length - 1] !== tracked) {\n          returnData[thingToTrack][returnData.length - 1] = tracked;\n          returnData[thingToTrack].push(tracked);\n        }\n      };\n    }\n  }\n\n  function log(thingToLog, listenerCollection, diffOnly) {\n    var capThingToLog = thingToLog.charAt(0).toUpperCase() + thingToLog.slice(1);\n    if (opts['log' + capThingToLog]) {\n      var last;\n      listenerCollection['log' + capThingToLog] = function(tracked) {\n        if (!diffOnly || last !== tracked) {\n          last = tracked;\n          var color = colorLog(thingToLog, tracked);\n          if (color) {\n            console.log('%c' + thingToLog + ':', color, tracked);\n          } else {\n            console.log(thingToLog + ':', tracked);\n          }\n        }\n      };\n    }\n  }\n\n  function getColor(metric, threshold) {\n    if (metric > threshold) {\n      return 'red';\n    } else if (metric > 0.7 * threshold) {\n      return 'orange';\n    }\n    return 'green';\n  }\n\n  function colorLog(thingToLog, tracked) {\n    var color;\n    if (thingToLog === 'digest') {\n      color = 'color:' + getColor(tracked, opts.digestTimeThreshold);\n    } else if (thingToLog === 'watches') {\n      color = 'color:' + getColor(tracked, opts.watchCountThreshold);\n    }\n    return color;\n  }\n\n  function addDataToCanvas(watchCount, digestLength) {\n    var averageDigest = digestLength || lastDigestLength;\n    var digestColor = getColor(averageDigest, opts.digestTimeThreshold);\n    lastWatchCount = nullOrUndef(watchCount) ? lastWatchCount : watchCount;\n    var watchColor = getColor(lastWatchCount, opts.watchCountThreshold);\n    lastDigestLength = nullOrUndef(digestLength) ? lastDigestLength : digestLength;\n    $watchCount.text(lastWatchCount).css({color: watchColor});\n    $digestTime.text(lastDigestLength.toFixed(2)).css({color: digestColor});\n\n    if (!digestLength) {\n      return;\n    }\n\n    // color the sliver if this is the first step\n    var ctx = cvs.getContext('2d');\n    if (noDigestSteps > 0) {\n      noDigestSteps = 0;\n      ctx.fillStyle = '#333';\n      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n    }\n\n    // mark the point on the graph\n    ctx.fillStyle = digestColor;\n    ctx.fillRect(graphSz.width - 1, Math.max(0, graphSz.height - averageDigest), 2, 2);\n  }\n\n  // Shift the canvas to the left.\n  function shiftLeft() {\n    if (state.active) {\n      setTimeout(shiftLeft, 250);\n      var ctx = cvs.getContext('2d');\n      var imageData = ctx.getImageData(1, 0, graphSz.width - 1, graphSz.height);\n      ctx.putImageData(imageData, 0, 0);\n      ctx.fillStyle = ((noDigestSteps++) > 2) ? 'black' : '#333';\n      ctx.fillRect(graphSz.width - 1, 0, 1, graphSz.height);\n    }\n  }\n\n  // start everything\n  shiftLeft();\n  if (!$rootScope.$$phase) {\n    $rootScope.$digest();\n  }\n\n  return returnData;\n}\n\nangular.module('angularStats', []).directive('angularStats', function() {\n  var index = 1;\n  return {\n    scope: {\n      digestLength: '@',\n      watchCount: '@',\n      watchCountRoot: '@',\n      onDigestLengthUpdate: '&?',\n      onWatchCountUpdate: '&?'\n    },\n    link: function(scope, el, attrs) {\n      hijackDigest();\n      var directiveIndex = index++;\n\n      setupDigestLengthElement();\n      setupWatchCountElement();\n      addWatchCountListener();\n      addDigestLengthListener();\n      scope.$on('$destroy', destroyListeners);\n\n      function setupDigestLengthElement() {\n        if (attrs.hasOwnProperty('digestLength')) {\n          var digestEl = el;\n          if (attrs.digestLength) {\n            digestEl = angular.element(el[0].querySelector(attrs.digestLength));\n          }\n          listeners.digestLength['ngStatsDirective' + directiveIndex] = function(length) {\n            window.dirDigestNode = digestEl[0];\n            digestEl.text((length || 0).toFixed(2));\n          };\n        }\n      }\n\n      function setupWatchCountElement() {\n        if (attrs.hasOwnProperty('watchCount')) {\n          var watchCountRoot;\n          var watchCountEl = el;\n          if (scope.watchCount) {\n            watchCountEl = angular.element(el[0].querySelector(attrs.watchCount));\n          }\n\n          if (scope.watchCountRoot) {\n            if (scope.watchCountRoot === 'this') {\n              watchCountRoot = el;\n            } else {\n              // In the case this directive is being compiled and it's not in the dom,\n              // we're going to do the find from the root of what we have...\n              var rootParent;\n              if (attrs.hasOwnProperty('watchCountOfChild')) {\n                rootParent = el[0];\n              } else {\n                rootParent = findRootOfElement(el);\n              }\n              watchCountRoot = angular.element(rootParent.querySelector(scope.watchCountRoot));\n              if (!watchCountRoot.length) {\n                throw new Error('no element at selector: ' + scope.watchCountRoot);\n              }\n            }\n          }\n\n          listeners.watchCount['ngStatsDirective' + directiveIndex] = function(count) {\n            var watchCount = count;\n            if (watchCountRoot) {\n              watchCount = getWatcherCountForElement(watchCountRoot);\n            }\n            watchCountEl.text(watchCount);\n          };\n        }\n      }\n\n      function addWatchCountListener() {\n        if (attrs.hasOwnProperty('onWatchCountUpdate')) {\n          listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex] = function(count) {\n            scope.onWatchCountUpdate({watchCount: count});\n          };\n        }\n      }\n\n      function addDigestLengthListener() {\n        if (attrs.hasOwnProperty('onDigestLengthUpdate')) {\n          listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex] = function(length) {\n            scope.onDigestLengthUpdate({digestLength: length});\n          };\n        }\n      }\n\n      function destroyListeners() {\n        delete listeners.digestLength['ngStatsDirectiveUpdate' + directiveIndex];\n        delete listeners.watchCount['ngStatsDirectiveUpdate' + directiveIndex];\n        delete listeners.digestLength['ngStatsDirective' + directiveIndex];\n        delete listeners.watchCount['ngStatsDirective' + directiveIndex];\n      }\n    }\n  };\n\n  function findRootOfElement(el) {\n    var parent = el[0];\n    while (parent.parentElement) {\n      parent = parent.parentElement;\n    }\n    return parent;\n  }\n});\n\n// UTILITY FUNCTIONS\n\nfunction getRootScope() {\n  if ($rootScope) {\n    return $rootScope;\n  }\n  var scopeEl = document.querySelector(scopeSelectors);\n  if (!scopeEl) {\n    return null;\n  }\n  $rootScope = angular.element(scopeEl).scope().$root;\n  return $rootScope;\n}\n\n// Uses timeouts to ensure that this is only run every 300ms (it's a perf bottleneck)\nfunction getWatcherCount() {\n  clearTimeout(watchCountTimeout);\n  var now = timerNow();\n  if (now - lastWatchCountRun > 300) {\n    lastWatchCountRun = now;\n    lastWatchCount = getWatcherCountForScope();\n  } else {\n    watchCountTimeout = setTimeout(function() {\n      updateData(getWatcherCount());\n    }, 350);\n  }\n  return lastWatchCount;\n}\n\nfunction getWatcherCountForElement(element) {\n  var startingScope = getClosestChildScope(element);\n  return getWatcherCountForScope(startingScope);\n}\n\nfunction getClosestChildScope(element) {\n  element = angular.element(element);\n  var scope = element.scope();\n  if (!scope) {\n    element = angular.element(element.querySelector(scopeSelectors));\n    scope = element.scope();\n  }\n  return scope;\n}\n\nfunction getWatchersFromScope(scope) {\n  return scope && scope.$$watchers ? scope.$$watchers : [];\n}\n\n// iterate through listeners to call them with the watchCount and digestLength\nfunction updateData(watchCount, digestLength) {\n  // update the listeners\n  if (!nullOrUndef(watchCount)) {\n    angular.forEach(listeners.watchCount, function(listener) {\n      listener(watchCount);\n    });\n  }\n  if (!nullOrUndef(digestLength)) {\n    angular.forEach(listeners.digestLength, function(listener) {\n      listener(digestLength);\n    });\n  }\n}\n\nfunction nullOrUndef(item) {\n  return item === null || item === undefined;\n}\n\nfunction getWatcherCountForScope(scope) {\n  var count = 0;\n  iterateScopes(scope, function(childScope) {\n    count += getWatchersFromScope(childScope).length;\n  });\n  return count;\n}\n\nfunction iterateScopes(currentScope, fn) {\n  if (typeof currentScope === 'function') {\n    fn = currentScope;\n    currentScope = null;\n  }\n  currentScope = currentScope || getRootScope();\n  currentScope = _makeScopeReference(currentScope);\n  if (!currentScope) {\n    return;\n  }\n  var ret = fn(currentScope);\n  if (ret === false) {\n    return ret;\n  }\n  return iterateChildren(currentScope, fn);\n}\n\nfunction iterateSiblings(start, fn) {\n  var ret;\n  /* eslint no-extra-boolean-cast:0 */\n  while (!!(start = start.$$nextSibling)) {\n    ret = fn(start);\n    if (ret === false) {\n      break;\n    }\n\n    ret = iterateChildren(start, fn);\n    if (ret === false) {\n      break;\n    }\n  }\n  return ret;\n}\n\nfunction iterateChildren(start, fn) {\n  var ret;\n  while (!!(start = start.$$childHead)) {\n    ret = fn(start);\n    if (ret === false) {\n      break;\n    }\n\n    ret = iterateSiblings(start, fn);\n    if (ret === false) {\n      break;\n    }\n  }\n  return ret;\n}\n\n\nfunction getScopeById(id) {\n  var myScope = null;\n  iterateScopes(function(scope) {\n    if (scope.$id === id) {\n      myScope = scope;\n      return false;\n    }\n  });\n  return myScope;\n}\n\nfunction _makeScopeReference(scope) {\n  if (_isScopeId(scope)) {\n    scope = getScopeById(scope);\n  }\n  return scope;\n}\n\nfunction _isScopeId(scope) {\n  return typeof scope === 'string' || typeof scope === 'number';\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./index.js\n **/","module.exports = __WEBPACK_EXTERNAL_MODULE_1__;\n\n\n/*****************\n ** WEBPACK FOOTER\n ** external \"angular\"\n ** module id = 1\n ** module chunks = 0\n **/"],"sourceRoot":""}